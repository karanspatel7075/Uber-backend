<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      th:replace="~{base::Layout(~{::section})}">

<head>
  <meta charset="UTF-8">
  <title>Ride Details | Navio</title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">


</head>

<body>
<section>

  <style>
    #map {
      height: 350px;
      width: 100%;
      border-radius: 12px;
      margin-top: 15px;
    }
    /* Add a subtle shadow/outline to the car icon for better visibility */
    .leaflet-marker-icon.driver-icon {
        filter: drop-shadow(0 0 2px rgba(0,0,0,0.7));
    }
  </style>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <div class="container mt-5">
    <div class="card shadow-lg p-4 rounded-4">

      <h3 class="text-center mb-4">Ride Details</h3>

      <div>
        <p><b>Ride ID:</b> <span th:text="${ride.id}"></span></p>
        <p><b>Pickup:</b> <span th:text="${ride.pickUpLocation}"></span></p>
        <p><b>Drop:</b> <span th:text="${ride.dropLocation}"></span></p>
        <p><b>Status:</b> <span th:text="${ride.status}"></span></p>
      </div>

      <div id="map"></div>

      <div class="text-center mt-4">
        <a th:href="@{/driver/chat(rideId=${ride.id})}" class="btn btn-primary px-4">
          ðŸ’¬ Chat with Rider
        </a>
      </div>

      <div class="text-center mt-3">

        <form th:if="${ride.status == 'Accepted'}"
              th:action="@{/driver/startRide/{rideId}(rideId=${ride.id})}" method="post" class="d-inline">
          <button type="submit" class="btn btn-warning px-4">Start Ride</button>
        </form>

        <form th:if="${ride.status == 'Ongoing'}"
              th:action="@{/driver/endRide/{rideId}(rideId=${ride.id})}" method="post" class="d-inline">
          <input type="number" name="distance" step="0.1" placeholder="Distance (km)"
                 required class="form-control d-inline-block w-auto me-2">
          <button type="submit" class="btn btn-success px-4">End Ride</button>
        </form>

        <form th:if="${ride.status == 'Completed'}"
              th:action="@{/driver/updateLocation}" method="post" class="d-inline">
          <input type="hidden" name="rideId" th:value="${ride.id}">
          <input type="hidden" name="dropLocation" th:value="${ride.dropLocation}">
          <button type="submit" class="btn btn-success px-4">End Ride</button>
        </form>

      </div>
    </div>
  </div>
  <script th:inline="javascript">
    document.addEventListener("DOMContentLoaded", async () => {

        const pickup = {
            lat: [[${ride.pickUpLatitude}]],
            lng: [[${ride.pickUpLongitude}]]
        };

        const drop = {
            lat: [[${ride.dropLatitude}]],
            lng: [[${ride.dropLongitude}]]
        };

        const rideId = [[${ride.id}]];

        // MAP
        const map = L.map("map").setView([pickup.lat, pickup.lng], 14);

        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png")
            .addTo(map);

        // Custom Icons for Pickup/Drop for realism
        const pickupIcon = L.icon({
            iconUrl: 'https://cdn-icons-png.flaticon.com/512/854/854901.png', // A generic pin/start point
            iconSize: [35, 35],
            iconAnchor: [17, 35]
        });
        const dropIcon = L.icon({
            iconUrl: 'https://cdn-icons-png.flaticon.com/512/854/854903.png', // A generic pin/end point
            iconSize: [35, 35],
            iconAnchor: [17, 35]
        });


        // Markers
        L.marker([pickup.lat, pickup.lng], { icon: pickupIcon }).addTo(map).bindPopup("Pickup");
        L.marker([drop.lat, drop.lng], { icon: dropIcon }).addTo(map).bindPopup("Drop");

        // ------------------------------------------------------------------------------------
        // ðŸš— STEP 1: Get real road route from OSRM API
        // ------------------------------------------------------------------------------------
        let url = `https://router.project-osrm.org/route/v1/driving/${pickup.lng},${pickup.lat};${drop.lng},${drop.lat}?overview=full&geometries=geojson`;

        const response = await fetch(url);
        const data = await response.json();

        const route = data.routes[0].geometry.coordinates;

        // Convert [lng, lat] â†’ [lat, lng]
        const latLngRoute = route.map(coord => [coord[1], coord[0]]);

        // Draw polyline along road
        const routeLine = L.polyline(latLngRoute, {
            color: "#007bff", // Use primary color for route
            weight: 5,
            opacity: 0.7
        }).addTo(map);

        // Fit map to route
        map.fitBounds(routeLine.getBounds());

        // ------------------------------------------------------------------------------------
        // ðŸš• STEP 2: Animate driver icon along the route (Improved)
        // ------------------------------------------------------------------------------------
        let driverIcon = L.icon({
            // New, better car icon (e.g., a taxi/car from Flaticon)
            iconUrl: "https://cdn-icons-png.flaticon.com/512/3202/3202926.png", // Example: A black car/taxi icon
            iconSize: [40, 40], // Slightly larger
            iconAnchor: [20, 20],
            className: 'driver-icon' // For custom CSS
        });

        // Leaflet helper function to calculate bearing (angle) between two points
        function getBearing(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // metres
            const Ï†1 = lat1 * Math.PI / 180;
            const Ï†2 = lat2 * Math.PI / 180;
            const Î»1 = lon1 * Math.PI / 180;
            const Î»2 = lon2 * Math.PI / 180;

            const y = Math.sin(Î»2 - Î»1) * Math.cos(Ï†2);
            const x = Math.cos(Ï†1) * Math.sin(Ï†2) - Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î»2 - Î»1);
            const bearing = Math.atan2(y, x) * 180 / Math.PI;

            // Normalize bearing to 0-360 degrees, and add 90 degrees offset to match icon orientation
            return (bearing + 360) % 360;
        }

        let driverMarker = L.marker(latLngRoute[0], { icon: driverIcon }).addTo(map);

        let index = 0;
        // **NEW:** Control the animation speed (smaller delta moves slower)
        const animationDelta = 2;

        function animateDriver() {
            if (index >= latLngRoute.length) return;

            // **NEW:** Calculate bearing for rotation
            if (index + animationDelta < latLngRoute.length) {
                const currentPoint = latLngRoute[index];
                const nextPoint = latLngRoute[index + animationDelta];

                const bearing = getBearing(currentPoint[0], currentPoint[1], nextPoint[0], nextPoint[1]);

                // Rotate the icon element using CSS transform
                driverMarker._icon.style.transform += ` rotate(${bearing}deg)`;
            }

            // Update marker position
            driverMarker.setLatLng(latLngRoute[index]);

            // Send simulated location to backend
            fetch("/driver/updateLocationLive", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    rideId: rideId,
                    lat: latLngRoute[index][0],
                    lng: latLngRoute[index][1]
                })
            });

            // Increment index by a 'delta' to control speed
            index += animationDelta;

            // Use setTimeout for a more controlled, slower, and visually smoother 'real-time' movement
            setTimeout(animateDriver, 50); // Move every 50ms
        }

        // Only start the animation if the ride is 'Accepted' or 'Ongoing'
        const rideStatus = [[${ride.status}]];
        if (rideStatus === 'Accepted' || rideStatus === 'Ongoing') {
            animateDriver();  // Start animation
        }

    });
  </script>

</section>
</body>
</html>
